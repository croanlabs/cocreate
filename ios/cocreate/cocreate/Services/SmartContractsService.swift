//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: space.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import Foundation

import TrustWalletCore
import Web3
import CryptoSwift

class CocreateContract: GenericERC721Contract {}

extension CocreateContract {
    
    // function createToken(address to, bytes32 tokenId, string memory ipfsId) public
    func createToken(to: EthereumAddress, tokenId: [Byte], ipfsId: String) -> SolidityInvocation {
        let inputs = [
            SolidityFunctionParameter(name: "to", type: .address),
            SolidityFunctionParameter(name: "tokenId", type: .array(type: .uint8, length: 32)),
            SolidityFunctionParameter(name: "ipfsId", type: .string)
        ]
        let method = SolidityNonPayableFunction(name: "createToken", inputs: inputs, handler: self)
        return method.invoke(to, tokenId, ipfsId)
    }
 
    // function joinTokens (bytes32[] memory _tokens, string memory _newToken) public
    func joinTokens(tokens: [Bytes], newTokenId: String) -> SolidityInvocation {
        let inputs = [
            SolidityFunctionParameter(name: "_tokens", type: .array(type: .bytes(length: 32), length: nil)),
            SolidityFunctionParameter(name: "_newToken", type: .string)
        ]
        let method = SolidityNonPayableFunction(name: "joinTokens", inputs: inputs, handler: self)
        return method.invoke(tokens, newTokenId)
    }
    
    // function joinApprove(bytes32[] memory _tokens, uint[] memory _ownerPercentage, string memory _newToken) public
    func joinApprove(tokens: [Bytes], percentage: UInt32, newTokenId: String) -> SolidityInvocation {
        let inputs = [
            SolidityFunctionParameter(name: "_tokens", type: .array(type: .bytes(length: 32), length: nil)),
            SolidityFunctionParameter(name: "_ownerPercentage", type: .uint32),
            SolidityFunctionParameter(name: "_newToken", type: .string)
        ]
        let method = SolidityNonPayableFunction(name: "joinApprove", inputs: inputs, handler: self)
        return method.invoke(tokens, percentage, newTokenId)
    }
}

class SmartContractsService {
    let web3: Web3
    let contract: CocreateContract
    var owner1: EthereumPrivateKey
    var owner2: EthereumPrivateKey
    var hash1: Array<UInt8>
    var hash2: Array<UInt8>
    var first = true
    var second = true
    var pollTimer = Timer()
    var mergedIpfs: String
    
    init () {
        web3 = Web3(rpcURL: "http://127.0.0.1:7545")
        
        let contractAddress = try! EthereumAddress(hex: "0xbdc7FC2EFF69A1Cd88A32884aa7CE46e0b7D532C", eip55: true)
        contract = web3.eth.Contract(type: CocreateContract.self, address: contractAddress)
        
        let wallet = HDWallet(mnemonic: "bench garlic comic pumpkin reduce biology keen debate club dinner board clock", passphrase: "") // Ganache generated mnenomic for testing
        
        var rawKey = wallet.getKey(at: DerivationPath("m/44'/60'/0'/0/4")!)
        owner1 = try! EthereumPrivateKey(hexPrivateKey: rawKey.data.toHexString())
        rawKey = wallet.getKey(at: DerivationPath("m/44'/60'/0'/0/5")!)
        owner2 = try! EthereumPrivateKey(hexPrivateKey: rawKey.data.toHexString())
        
        let ipfs1 = UUID().uuidString
        let ipfs2 = UUID().uuidString
        
        mergedIpfs = UUID().uuidString
        
        hash1 = Digest.sha3(ipfs1.bytes, variant: .keccak256)
        hash2 = Digest.sha3(ipfs2.bytes, variant: .keccak256)
        
        
        _ = Timer.scheduledTimer(timeInterval: 15.0, target: self, selector: #selector(fireTimer), userInfo: nil, repeats: true)
        
        createToken(owner: owner1, ipfsId: "fdsfdsfdasf")
        
        sleep(5)
        
        createToken(owner: owner2, ipfsId: ipfs2)
    }
    
    @objc func fireTimer() {
        if (contract.events.last?.name == "TokensJoined") {
            print("token joined")
        }
        else {
            print("not joined yet")
            if (first) {
                pollTimer.invalidate()
                pollTimer = Timer.scheduledTimer(timeInterval: 5.0, target: self, selector: #selector(fireTimer), userInfo: nil, repeats: true)
                joinApprove(owner: owner1, tokens: [hash1, hash2], percentage: 5000, ipfsId: mergedIpfs)
                print("approved owner1")
                first = false
                pollTimer = Timer.scheduledTimer(timeInterval: 5.0, target: self, selector: #selector(fireTimer), userInfo: nil, repeats: true)
            } else {
                if (second) {
                    approveAndJoin(owner: owner2, tokens: [hash1, hash2], percentage: 5000, ipfsId: mergedIpfs)
                    print("approve and join owner2")
                    second = false
                    pollTimer.invalidate()
                }
            }
        }
    }
    
    func createToken(owner: EthereumPrivateKey, ipfsId: String) {
        firstly {
            self.web3.eth.getTransactionCount(address: owner.address, block: .latest)
        }.then { nonce in
            try self.contract.createToken(to: owner.address, tokenId: Digest.sha3(ipfsId.bytes, variant: .keccak256), ipfsId: ipfsId).createTransaction(
                nonce: nonce,
                from: owner.address,
                value: EthereumQuantity(quantity: 0),
                gas: EthereumQuantity(quantity: 3000000),
                gasPrice: EthereumQuantity(quantity: 21.gwei)
                )!.sign(with: owner, chainId: 5777).promise
        }.then { tx in
            self.web3.eth.sendRawTransaction(transaction: tx)
        }.done { txHash in
            print(txHash.bytes.toHexString())
        }.catch { error in
            print(error)
        }
    }
    
    func joinToken(owner: EthereumPrivateKey, tokens: [Bytes], ipfsId: String) {
        firstly {
            self.web3.eth.getTransactionCount(address: owner.address, block: .latest)
        }.then { nonce in
            try self.contract.joinTokens(tokens: tokens, newTokenId: ipfsId).createTransaction(
                nonce: nonce,
                from: owner.address,
                value: EthereumQuantity(quantity: 0),
                gas: EthereumQuantity(quantity: 100000),
                gasPrice: EthereumQuantity(quantity: 21.gwei)
                )!.sign(with: owner, chainId: 5777).promise
        }.then { tx in
            self.web3.eth.sendRawTransaction(transaction: tx)
        }.done { txHash in
            print(txHash.bytes.toHexString())
        }.catch { error in
            print(error)
        }
    }
    
    func joinApprove(owner: EthereumPrivateKey, tokens: [Bytes], percentage: UInt32, ipfsId: String) {
        firstly {
            self.web3.eth.getTransactionCount(address: owner.address, block: .latest)
        }.then { nonce in
            try self.contract.joinApprove(tokens: tokens, percentage: percentage, newTokenId: ipfsId).createTransaction(
                nonce: nonce,
                from: owner.address,
                value: EthereumQuantity(quantity: 0),
                gas: EthereumQuantity(quantity: 100000),
                gasPrice: EthereumQuantity(quantity: 21.gwei)
                )!.sign(with: owner, chainId: 5777).promise
        }.then { tx in
            self.web3.eth.sendRawTransaction(transaction: tx)
        }.done { txHash in
            print(txHash.bytes.toHexString())
        }.catch { error in
            print(error)
        }
    }
    
    func approveAndJoin(owner: EthereumPrivateKey, tokens: [Bytes], percentage: UInt32, ipfsId: String) {
        firstly {
            self.web3.eth.getTransactionCount(address: owner.address, block: .latest)
        }.then { nonce in
            try self.contract.joinApprove(tokens: tokens, percentage: percentage, newTokenId: ipfsId).createTransaction(
                nonce: nonce,
                from: owner.address,
                value: EthereumQuantity(quantity: 0),
                gas: EthereumQuantity(quantity: 100000),
                gasPrice: EthereumQuantity(quantity: 21.gwei)
                )!.sign(with: owner, chainId: 5777).promise
        }.then { tx in
            self.web3.eth.sendRawTransaction(transaction: tx)
        }.then { _ in
            self.web3.eth.getTransactionCount(address: owner.address, block: .latest)
        }.then { nonce in
            try self.contract.joinTokens(tokens: tokens, newTokenId: ipfsId).createTransaction(
                nonce: nonce,
                from: owner.address,
                value: EthereumQuantity(quantity: 0),
                gas: EthereumQuantity(quantity: 100000),
                gasPrice: EthereumQuantity(quantity: 21.gwei)
                )!.sign(with: owner, chainId: 5777).promise
        }.then { tx in
            self.web3.eth.sendRawTransaction(transaction: tx)
        }.done { txHash in
            print(txHash.bytes.toHexString())
        }.catch { error in
            print(error)
        }
    }
}
